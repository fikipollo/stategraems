(function(){var app=angular.module("protocols.controllers",["ang-dialogs","angular.backtop","protocols.services.protocol-list","protocols.directives.protocol-views","templates.directives.template","ui.bootstrap"]);app.directive("ngEnter",function(){return function(scope,element,attrs){element.bind("keydown keypress",function(event){if(event.which===13){scope.$apply(function(){scope.$eval(attrs.ngEnter)});event.preventDefault()}})}});app.controller("ProtocolListController",function($rootScope,$scope,$http,$stateParams,$dialogs,APP_EVENTS,ProtocolList){this.retrieveProtocolsData=function(group,force){$scope.setLoading(true);if(ProtocolList.getOld()>1||force){$http($rootScope.getHttpRequestConfig("POST","protocol-list",{headers:{"Content-Type":"application/json"},data:$rootScope.getCredentialsParams()})).then(function successCallback(response){$scope.isLoading=false;$scope.protocols=ProtocolList.setProtocols(response.data).getProtocols();$scope.tags=ProtocolList.updateTags().getTags();$scope.filteredProtocols=$scope.protocols.length;if(window.innerWidth>1500){$scope.visibleProtocols=14}else if(window.innerWidth>1200){$scope.visibleProtocols=10}else{$scope.visibleProtocols=6}$scope.visibleProtocols=Math.min($scope.filteredProtocols,$scope.visibleProtocols);$scope.setLoading(false)},function errorCallback(response){$scope.setLoading(false);debugger;var message="Failed while retrieving the protocols list.";$dialogs.showErrorDialog(message,{logMessage:message+" at ProtocolListController:retrieveProtocolsData."});console.error(response.data)})}else{$scope.protocols=ProtocolList.getProtocols();$scope.tags=ProtocolList.getTags();$scope.filteredProtocols=$scope.protocols.length;$scope.setLoading(false)}return this};$scope.filterProtocols=function(){$scope.filteredProtocols=0;$scope.user_id=$scope.user_id||Cookies.get("loggedUserID");return function(item){if($scope.show==="my_protocols"){if(!ProtocolList.isOwner(item,$scope.user_id)&&!ProtocolList.isMember(item,$scope.user_id)){return false}}var filterAux,item_tags;for(var i in $scope.filters){filterAux=$scope.filters[i].toLowerCase();if(!(item.protocol_name.toLowerCase().indexOf(filterAux)!==-1||item.description.toLowerCase().indexOf(filterAux)!==-1)){return false}}$scope.filteredProtocols++;return true}};$scope.getTagColor=function(_tag){var tag=ProtocolList.getTag(_tag);if(tag!==null){return tag.color}return""};$scope.isMember=function(protocol){$scope.user_id=$scope.user_id||Cookies.get("loggedUserID");return ProtocolList.isOwner(protocol,$scope.user_id)||ProtocolList.isMember(protocol,$scope.user_id)};$scope.$on(APP_EVENTS.protocolDeleted,function(event,args){debugger;this.retrieveProtocolsData("",true)});$scope.$on(APP_EVENTS.protocolSelection,function(event,args){debugger});this.showProtocolChooserChangeHandler=function(){this.retrieveProtocolsData($scope.show)};this.applySearchHandler=function(){var filters=arrayUnique($scope.filters.concat($scope.searchFor.split(" ")));$scope.filters=ProtocolList.setFilters(filters).getFilters()};this.filterByTag=function(tag){if(tag!=="All"){var filters=arrayUnique($scope.filters.concat(tag));$scope.filters=ProtocolList.setFilters(filters).getFilters()}};this.removeFilterHandler=function(filter){$scope.filters=ProtocolList.removeFilter(filter).getFilters()};this.showMoreProtocolsHandler=function(){if(window.innerWidth>1500){$scope.visibleProtocols+=10}else if(window.innerWidth>1200){$scope.visibleProtocols+=6}else{$scope.visibleProtocols+=4}$scope.visibleProtocols=Math.min($scope.filteredProtocols,$scope.visibleProtocols)};this.name="ProtocolListController";var me=this;if(!Cookies.get("currentExperimentID")){$dialogs.showInfoDialog('Please, choose first an study at the "Browse studies" section.');$state.go("experiments");return}$scope.protocols=ProtocolList.getProtocols();$scope.tags=ProtocolList.getTags();$scope.filters=ProtocolList.getFilters();$scope.filteredProtocols=$scope.protocols.length;if(window.innerWidth>1500){$scope.visibleProtocols=14}else if(window.innerWidth>1200){$scope.visibleProtocols=10}else{$scope.visibleProtocols=6}$scope.visibleProtocols=Math.min($scope.filteredProtocols,$scope.visibleProtocols);if($scope.protocols.length===1||$stateParams.force||$scope.force){this.retrieveProtocolsData("my_protocols",true)}});app.controller("ProtocolDetailController",function($state,$rootScope,$scope,$http,$stateParams,$timeout,$dialogs,APP_EVENTS,ProtocolList,TemplateList){this.retrieveProtocolDetails=function(protocol_id,force){$scope.model=ProtocolList.getProtocol(protocol_id);if($scope.model===null||force===true){$scope.setLoading(true);$http($rootScope.getHttpRequestConfig("POST","protocol-info",{headers:{"Content-Type":"application/json"},data:$rootScope.getCredentialsParams({protocol_id:protocol_id})})).then(function successCallback(response){$scope.model=ProtocolList.addProtocol(response.data);ProtocolList.adaptInformation([$scope.model])[0];$scope.setLoading(false)},function errorCallback(response){debugger;var message="Failed while retrieving the protocol's details.";$dialogs.showErrorDialog(message,{logMessage:message+" at ProtocolDetailController:retrieveProtocolDetails."});console.error(response.data);$scope.setLoading(false)})}};this.send_create_protocol=function(callback_caller,callback_function){$scope.setLoading(true);$http($rootScope.getHttpRequestConfig("POST","protocol-create",{headers:{"Content-Type":"application/json"},data:$rootScope.getCredentialsParams({protocol_json_data:$scope.model})})).then(function successCallback(response){console.info((new Date).toLocaleString()+"Protocol "+$scope.model.protocol_id+" successfully saved in server");$scope.model.protocol_id=response.data.newID;ProtocolList.addProtocol($scope.model);$scope.setLoading(false);callback_caller[callback_function](true)},function errorCallback(response){$scope.setLoading(false);debugger;var message="Failed while creating a new protocol.";$dialogs.showErrorDialog(message,{logMessage:message+" at ProtocolDetailController:send_create_protocol."});console.error(response.data);$scope.taskQueue.unshift({command:"create_new_protocol",object:null});callback_caller[callback_function](false)})};this.send_update_protocol=function(callback_caller,callback_function){$scope.setLoading(true);$http($rootScope.getHttpRequestConfig("POST","protocol-update",{headers:{"Content-Type":"application/json"},data:$rootScope.getCredentialsParams({protocol_json_data:$scope.model})})).then(function successCallback(response){console.info((new Date).toLocaleString()+"Protocol "+$scope.model.protocol_id+" successfully updated in server");$scope.setLoading(false);callback_caller[callback_function](true)},function errorCallback(response){debugger;var message="Failed while updating the protocol.";$dialogs.showErrorDialog(message,{logMessage:message+" at ProtocolDetailController:send_update_protocol."});console.error(response.data);$scope.taskQueue.unshift({command:"update_protocol",object:null});$scope.setLoading(false);callback_caller[callback_function](false)})};this.send_lock_protocol=function(newViewMode){$scope.setLoading(true);$http($rootScope.getHttpRequestConfig("POST","protocol-lock",{headers:{"Content-Type":"application/json"},data:$rootScope.getCredentialsParams({protocol_id:$scope.model.protocol_id})})).then(function successCallback(response){if(response.data.success){console.info((new Date).toLocaleString()+"object locked successfully");if(newViewMode==="edition"){$scope.initializeCountdownDialogs()}$scope.setViewMode(newViewMode||"view");$scope.setLoading(false)}else{$dialogs.showErrorDialog("Apparently user "+response.data.user_id+" opened this object for editing. </br>Please, try again later. If the problem persists, please contact with tecnical support.",{logMessage:(new Date).toLocaleString()+"EDITION DENIED FOR Protocol "+$scope.model.protocol_id});$scope.setLoading(false)}},function errorCallback(response){debugger;var message="Failed while sending lock request.";$dialogs.showErrorDialog(message,{logMessage:message+" at ProtocolDetailController:send_lock_protocol."});console.error(response.data);$scope.setLoading(false)});return this};this.send_unlock_protocol=function(callback_caller,callback_function){$scope.setLoading(true);$http($rootScope.getHttpRequestConfig("POST","protocol-unlock",{headers:{"Content-Type":"application/json"},data:$rootScope.getCredentialsParams({protocol_id:$scope.model.protocol_id})})).then(function successCallback(response){console.info((new Date).toLocaleString()+"object unlocked successfully");$scope.setLoading(false);if(callback_caller){callback_caller[callback_function](true)}else{$scope.setViewMode("view",true)}},function errorCallback(response){debugger;var message="Failed while sending unlock request.";$dialogs.showErrorDialog(message,{logMessage:message+" at ProtocolDetailController:send_unlock_protocol."});console.error(response.data);callback_caller[callback_function](false);$scope.setLoading(false)});return this};this.clean_task_queue=function(tasks_queue){console.info((new Date).toLocaleString()+"CLEANING TASK QUEUE");try{if(tasks_queue.length===0){return tasks_queue}var tasks_queue_temp;if(tasks_queue[0].command==="create_new_protocol"){tasks_queue_temp=[tasks_queue[0]]}else{tasks_queue_temp=[];tasks_queue_temp.push({command:"update_protocol",object:null});tasks_queue_temp.push({command:"clear_locked_status",object:null})}return tasks_queue_temp}catch(error){$scope.showErrorDialog("ERROR CLEANING TASK QUEUE: "+error,{soft:false});return tasks_queue}};this.execute_tasks=function(status){var error_message="";var current_task=$scope.getTaskQueue().shift();if(current_task!=null&&status){try{switch(current_task.command){case"create_new_protocol":console.info((new Date).toLocaleString()+"SENDING SAVE NEW protocol REQUEST TO SERVER");this.send_create_protocol(this,"execute_tasks");console.info((new Date).toLocaleString()+"SAVE NEW protocol REQUEST SENT TO SERVER");break;case"update_protocol":console.info((new Date).toLocaleString()+"SENDING UPDATE Protocol REQUEST TO SERVER");this.send_update_protocol(this,"execute_tasks");console.info((new Date).toLocaleString()+"UPDATE Protocol REQUEST SENT TO SERVER");break;case"clear_locked_status":console.info((new Date).toLocaleString()+"SENDING UNLOCK Protocol "+$scope.model.protocol_id+" REQUEST TO SERVER");this.send_unlock_protocol(this,"execute_tasks");console.info((new Date).toLocaleString()+"UNLOCK Protocol "+$scope.model.protocol_id+" REQUEST SENT TO SERVER");break;default:status=false;break}}catch(error){error_message=error.message;status=false;$scope.taskQueue.unshift(current_task)}if(!status){$dialogs.showErrorDialog("Failed trying to saved the changes.</br>Please try again.</br>Error: "+error_message)}}else if(status){$scope.setViewMode("view");$scope.setLoading(false);$dialogs.showSuccessDialog("Protocol "+$scope.model.protocol_id+" saved successfully")}else{status=false;$scope.taskQueue.unshift(current_task);$scope.setLoading(false)}};$scope.setViewMode=function(mode,restore){if(mode==="view"){$scope.panel_title="Protocol details.";$scope.clearCountdownDialogs();if(restore===true){me.retrieveProtocolDetails($scope.model.protocol_id,true)}}else if(mode==="creation"){$scope.panel_title="Protocol creation.";$scope.addNewTask("create_new_protocol",null)}else if(mode==="edition"){$scope.panel_title="Protocol edition.";this.addNewTask("clear_locked_status",null)}$scope.viewMode=mode};$scope.initializeCountdownDialogs=function(){console.error("initializeCountdownDialogs NOT IMPLEMENTED")};$scope.clearCountdownDialogs=function(){console.error("cleanCountdownDialogs NOT IMPLEMENTED")};this.deleteProtocolHandler=function(){var me=this;var current_user_id=""+Cookies.get("loggedUserID");if(ProtocolList.isOwner($scope.model,current_user_id)||current_user_id==="admin"){$http($rootScope.getHttpRequestConfig("POST","protocol-delete",{headers:{"Content-Type":"application/json; charset=utf-8"},data:$rootScope.getCredentialsParams({protocol_id:$scope.model.protocol_id,loggedUserID:current_user_id})})).then(function successCallback(response){$scope.setLoading(false);$dialogs.showSuccessDialog("The protocol was successfully deleted.");$state.go("protocols",{force:true})},function errorCallback(response){$scope.setLoading(false);var message="Failed while deleting the protocol.";$dialogs.showErrorDialog(message,{logMessage:message+" at ProtocolDetailController:deleteProtocolHandler."});console.error(response.data);debugger})}};this.acceptButtonHandler=function(){if(!$scope.protocolForm.$valid){$dialogs.showErrorDialog("Invalid form, please check the form and fill the empty fields.");return false}$scope.setTaskQueue(this.clean_task_queue($scope.getTaskQueue()));this.execute_tasks(true);return this};this.editButtonHandler=function(){var current_user_id=""+Cookies.get("loggedUserID");if(!ProtocolList.isOwner($scope.model,current_user_id)&&current_user_id!=="admin"){console.error((new Date).toLocaleString()+" EDITION REQUEST DENIED. Error message: User "+current_user_id+" has not Edition privileges over the Protocol "+$scope.model.protocol_id);$dialogs.showErrorDialog("Your user is not allowed to edit this protocol");return}console.info((new Date).toLocaleString()+"SENDING EDIT REQUEST FOR Protocol "+$scope.model.protocol_id+" TO SERVER");this.send_lock_protocol("edition");return this};this.cancelButtonHandler=function(){$scope.clearTaskQueue();if($scope.viewMode==="view"){$state.go("protocols")}else if($scope.viewMode==="edition"){this.send_unlock_protocol()}else{$state.go("protocols")}};this.name="ProtocolDetailController";var me=this;if(!Cookies.get("currentExperimentID")){$dialogs.showInfoDialog('Please, choose first an study at the "Browse studies" section.');$state.go("experiments");return}$scope.loadingComplete=false;$scope.model={};$scope.setViewMode($stateParams.viewMode||"view");$scope.getFormTemplate("protocol-form");if($stateParams.protocol_id!==null){this.retrieveProtocolDetails($stateParams.protocol_id)}else{$scope.model.protocol_id="[Autogenerated after saving]";$scope.model.owners=[{user_id:Cookies.get("loggedUserID")}];$scope.model.tags=[];$scope.model.files_location=[]}})})();